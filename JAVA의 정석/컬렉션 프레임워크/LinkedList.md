# LinkedList
&nbsp;크기를 변경 불가, 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸리는 배열의 단점을 보완하기 위해 linked list라는 자료구조가 생겼다.
&nbsp;링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터를 가지고 있다. 
`링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성`

## 추가와 삭제
&nbsp;삭제하고자 하는 요소[1]의 이전요소가[0] 삭제하고자 하는 요소의[1] 다음 요소[2]를 참조하도록 변경한다. [1] -> [3] 단 하나의 참조만 변경하면 삭제가 이루어진다. **배열처럼 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다**.<br>
```0x200[0x300, 0] ➡️ 0x300[0x400, 1] ➡️ 0x400[null, 2]```<br>
```0x200[0x400, 0] ➡️ 0x400[null, 2]```<br>
<br>
&nbsp;새로운 데이터를 추가할 때는 새로운 요소[3]를 생성한 다음 추가하고자 하는 위치의 이전 요소의[0] 참조를 새로운 요소에 대한 참조로 변경해주고, 새로운 요소가 그 다음 요소[2]를 참조하도록 변경하기 때문에 처리속도가 매우 빠르다.
```0x200[0x500, 0] -> 0x500[0x300, 3] -> 0x300[null, 2]```

## ArrayList vs LinkedList
&nbsp; ArrayList는 순차적인 저장을 하기 때문에 간단한 계산으로 원하는 요소의 주소를 얻어 저장된 데이터를 읽어올 수 있지만, 불연속적으로 저장을 하는 LinkedList는 각 요소들이 서로 연결되어 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 데이터를 얻을 수 있다. <br>
|컬렉션|읽기(접근시간)|추가/삭제|비고|
|--|--|--|--|
|ArrayList|빠르다|느리다|순차적인 추가삭제는 더 빠름.<br>비효율적인 메모리사용|
|LinkedList|느리다|빠르다|데이터가 많을수록 접근성이 떨어짐|

`!ArrayList의 초기 용량이 초과할 경우 배열의 크기를 1.5배 증가시키는 방식(새로운 배열을 생성하고(Arrays.copyOf()) 저장될 연속된 공간을 찾아 새롭게 복사한다.)이 메모리사용에 비효율적이다.`
